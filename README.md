# [실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1/dashboard)

## 2. 프로젝트 환경설정

### 프로젝트 생성

- `Spring Initializr Java Support` extension으로 프로젝트 생성했다.
- groupId
  - 프로젝트를 만든 조직이나 그룹을 식별하는 ID
  - 보통 도메인을 거꾸로 쓴 형식 (예: com.example, org.springframework.boot)
- artifactId
  - 해당 프로젝트(모듈)의 고유 이름을 의미
  - user-api, order-service, auth-core
- 요즘은 `jsp`보다 `thymeleaf` 권장
- DB는 mysql8을 사용함

### 라이브러리 살펴보기

- `./gradlew dependencies`: 의존관계 설명

### View 환경 설정

- `thymeleaf`를 spring에서 밀어줌 + 사용법을 약간 익혀야한다

### H2 데이터베이스 설치

### JPA와 DB 설정, 동작확인

- show_sql속성은 system out을 통해 출력하기에 logging으로 출력 하는게 권장된다.
- `@PersistenceContext`: 부트가 엔티티매니저 객체 주입
- save하고 멤버 대신 id를 반환하는건 커맨드와 쿼리를 분리해라를 따르는 것
  - 명령과 조회의 분리
  - Command 데이터를 변경하는 작업 (예: save(), delete(), update())
  - Query 데이터를 조회하는 작업 (예: findById(), getUser())
- 인텔리제이에 테스트 코드를 생성해주는 기능이 있는 것 같은데 `Symflower` 익스텐션으로 대체
- `@Transactional`는 spring 껄 import할 것
- 왠만한 라이브러리들은 스프링부트에서는 해당 부트버전에 적합한 버전이 이미 정해져있음 그래서 라이브러리 버전을 명시하지 않아도 그 버전을 사용
- `p6spy-spring-boot-starter`는 파라미터까지 sql에 넣어보여줘 좋지만 운영 배포까지는 성능적 문제로 고민 필요

## 3. 도메인 분석 설계

### 요구사항 분석

- 회원 기능
  - 회원 등록
  - 회원 조회
- 상품 기능
  - 상품 등록
  - 상품 수정
  - 상품 조회
- 주문 기능
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다.
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문시 배송 정보를 입력할 수 있다.

### 도메인 모델과 테이블 설계

- 개념들을 모델화하고 모델들의 관계를 고려
- 내용 및 설계 구조가 ORM 기본편에서 나온 것과 유사
- 외래 키가 있는 곳을 연관관계의 주인

  - 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제
  - 연관관계의 주인을 반대로 정하면 관리하지 않는 테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수가 어렵고
  - 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있다.

### 엔티티 클래스 개발1

- @OneToOne 에선 포린키를 많이 어세스 하는 쪽에 두는 것을 선호

### 엔티티 클래스 개발2

- mysql enum 값 필수
- 값 타입은 변경 불가능하게 설계해야 한다. - address
  - JPA 스펙상 엔티티나 임베디드 타입( @Embeddable )은 자바 기본 생성자 default constructor)를 public 또는 protected 로 설정해야 한다.
  - JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플랙션 같은 기술을 사용할 수 있도록 지원해야 하기 때문이다.
- 생성된 스크립트를 바탕으로 검증하고 사용해라

### 엔티티 설계시 주의점

- 엔티티 설계시 주의점
  - 엔티티에는 가급적 Setter를 사용하지 말자 - 도메인(비즈니스) 메서드
- 모든 연관관계는 지연로딩으로 설정!
  - 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.
  - 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
  - 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다.
  - 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
- 컬렉션은 필드에서 초기화 하자.
  - null 문제에서 안전하다.
- 테이블, 컬럼명 생성 전략
  - 스프링 부트에서 하이버네이트 기본 매핑 전략을 변경해서 실제 테이블 필드명은 다름
  - 하이버네이트 기존 구현: 엔티티의 필드명을 그대로 테이블의 컬럼명으로 사용(SpringPhysicalNamingStrategy)
  - 스프링 부트 신규 설정 - 카멜 케이스 -> 언더스코어(memberPoint member_point)

## 4. 애플리케이션 구현 준비

- 로그인과 권한 관리X
- 파라미터 검증과 예외 처리X
- 계층형 구조 사용
  - controller, web: 웹 계층
  - service: 비즈니스 로직, 트랜잭션 처리
  - repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
  - domain: 엔티티가 모여 있는 계층, 모든 계층에서 사용
- controller -> service -> repository -> DB
  - 서비스가 불필요하다면 controller에서 레포를 바로 호출하게 처리할 것이다.
    - 방향은 단뱡항으로 간다.
    - 좀더 실용적인데, 실무에서도 이렇게 할지는 애매
- 개발 순서: 서비스, 리포지토리 계층을 개발하고, 테스트 케이스를 작성해서 검증, 마지막에 웹 계층 적용

## 5. 회원 도메인 개발

### 회원 리포지토리 개발

- JPQL은 SQL과 문법은 매우 유사, **from의 대상이 테이블 대신 엔티티**

### 회원 서비스 개발

- class level에서 @Transactional를 선언하면 퍼블릭메서드 전부 적용된다.
- 일반적으로 조회가 더 많으니 @Transactional(readOnly = true)를 클래스레벨에서 적용하고 개별 쓰기 메서드에 따로 적용
- @Transactional는 서비스 계층에 붙이는게 더 적합하다
  - 트랜잭션은 비즈니스 로직 단위로 관리되어야 함
  - 의도치 않은 트랜잭션 분리 가능성
  - 관심사 분리 위반
- 중첩해서 쓰면 가장 바깥쪽의 트랜잭션이 우선적으로 적용
- validateDuplicatedMember 처럼 중복 방지 로직이 있더라도, 멀티스레드 환경에선 추가적인 방어 로직이 필요 (멤버의 네임을 유니크 제약조건으로 잡음)

- 프로퍼티에 autowired를 사용하는 방법도 많이 쓰지만, 바꿀 수 있는 방법이 없음
- setter injection은 변경할 수 있지만, 런타임에 변경가능성이 열려 있다는게 문제
- 가장 권장하는 방식은 생성자 인젝션
  - 생성자에 autowired 어노테이션 불필요
  - 테스트 케이스 작성할 때, 프로퍼티 변경가능
- @RequiredArgsConstructor와 같이 사용해주는게 가장 좋다
  - 파이널 필드에 대해서만 생성자 생성

### 회원 기능 테스트

- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야 한다.
-

- given -> when -> then

- 테스트 시,test폴더에 있는 리소스가 우선권을 가짐
- h2 db는 jvm 메모리에서 실행가능해, 설정을 따로안주면 인메모리로 실행가능

## 6. 상품 도메인 개발

### 상품 엔티티 개발(비즈니스 로직 추가)

- 커스텀 에러의 개별 생성자들은 vscode로 생성하는 법을 못찾음 - 직접 작성해야 하는 것 같다.

### 상품 리포지토리 개발

- persist 사용 시:
  - 이미 영속성 컨텍스트에 같은 엔티티가 있으면 예외가 발생할 수 있습니다.
  - 새로운 엔티티에만 사용하세요.
- merge 사용 시:
  - 반환된 엔티티(managedItem)를 사용해야 영속성 컨텍스트에서 관리됩니다.
  - 불필요한 데이터베이스 조회가 발생할 수 있으므로, 가능하면 영속 상태 엔티티를 직접 수정하는 것이 더 효율적입니다.

### 상품 서비스 개발

- 상품 레포지토리에 위임만 해서 개발 간단
- 서비스 계층은 컨트롤러와 리포지토리 사이에서 비즈니스 로직을 수행하거나, 여러 리포지토리 작업을 조율하며, 주로 데이터베이스 접근은 리포지토리에 위임하는 역할로 직접 사용자 요청을 처리하거나 DB 스키마를 관리하지 않음

## 7. 주문 도메인 개발

### 주문, 주문상품 엔티티 개발

- 복잡한 엔티티는 생성 스태틱 메서드가 있으면 좋다
  - 생성 메서드로 묶어놔야 유지보수가 편함

### 주문 서비스 개발

- 생성 메서드를 사용하게 하기위해 다른 생성 방식을 막는게 좋다
  - 빈 생성자는 JPA에서 필요로 하기에 protected로 작성해줌
    - JPA 구현체(가장 흔한 것이 하이버네이트)는 데이터베이스에서 엔티티나 임베디드 객체를 로딩할 때, 리플렉션을 사용하여 해당 클래스의 인스턴스를 생성합니다.
    - 이때 인자 없는(no-argument) 기본 생성자가 필요합니다.
  - protected로 설정하면 외부 패키지나 해당 클래스를 상속받지 않은 클래스에서는 직접 new Address()와 같이 인스턴스를 생성할 수 없습니다.

```java
// 1
protected OrderItem() {}
// 2
@NoArgsConstructor(access = AccessLevel.PROTECTED)
```

- 데이터를 변경할 때 기존에는 쿼리를 다 날려줘야 하지만, JPA는 객체 값만 변경하면 끝
- 비즈니스 로직이 대부분 엔티티에 있다.
- 엔티티에 비즈니스 로직을 몰아 넣는 스타일을 도메인 모델 패턴이라 함
- 엔티티에 로직이 없고 서비스계층에 있으면 트랜잭션 스크립트 패턴

### 주문 기능 테스트

- 좋은 테스트는 디펜던시가 없을 수록 좋다
  - 디비, 스프링 포함
  - 단위테스트 말고 레포지토리나 다른 얽혀있는 기능들을 테스트할때 어느정도 한계는 있을 것 같다.
- 도메인 모델 패턴에서는 도메인의 도메인 메서드들에 대해 테스트를 작성해 비즈니스 로직에 문제없는지 확인 가능

### 주문 검색 기능 개발

- JPA에서 동적쿼리를 어떻게 해결하나
- JPA Criteria는 JPA 표준 스펙이지만 실무에서 사용하기에 너무 복잡하다.
- queryDSL 써라
- 스트링 형식의 SQL 보다 자바코드로 작성하면 컴파일 시점에 잘못 쓴걸 알 수 있다.
- boot + spring data JPA + queryDSL는 프로젝트 필수적으로 챙긴다 하심

## 8. 웹 계층 개발

### 홈 화면과 레이아웃

- devtools 사용시 html은 리컴파일만 해주면 변경
  - vscode에선 특정 익스텐션을 설치해야 한다는데 설치가 막혀있어 skip

### 회원 등록

- DTO와 엔티티는 분리

### 회원 목록 조회

### 상품 등록

### 상품 목록

### 상품 수정

### 변경 감지와 병합(merge)

### 상품 주문

### 주문 목록 검색, 취소

### 다음으로
